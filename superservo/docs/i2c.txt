SuperServo I2C Protocol Implimentation
Aug 28th, 2003



The I2C implimentation on the SuperServo is based on sending commands to the
servo and then reading the result. Thus, typically, each operation on the 
servo will contain two messages, a write and a subsequent read or write. 

However, there are enhancements to this mode that greatly decrease the bus
traffic for repeated operations such as reading the current servo position.

A message on the I2C bus is defined in this document to be the bytes sent
between each I2C start and stop condition. A command message is 1, 2, or
more associated messages that make up a single servo command operation.

Commands sent to the servo are either single operation (mode B) command 
messages or multi operation (mode A) command messages. Single operation 
command messages contain the complete servo command in a single I2C message. 
Multi operation command messages require 2 or more I2C messages. Single 
operation command messages do not interfere with the setup of multi operation 
command messages and can be interplexed with them. Multi operation command 
messages must be performed sequentially --- where a single multi operation 
command is being performed at any one time.

How to interpret command descriptions
   in this document:
	[DA]	The device (servo) address. This is configured via the 
		solderable address jumper on the servo or by the value
		stored in eeprom.

	rn	where n is 0,1,2,...n. The index location of the 
		specified register.

	[x]	The contents of the specified register 'x'.

	(x)	The byte x is not required to be sent in this I2C 
		message.

	{	The I2C start signal

	}	The I2C stop signal

	0xff	or any hex value means the literal byte.

Commands:




		*** DUAL OPERATION (MODE A) COMMANDS ***


0x00 Reserved / Null Command

	Used to signal the continuation of a multi operation command message.


0x01/R Read device registers (mode A)

	Send { [DA] 0x01 r0 r1 r2 ... rn }
	Receive { [DA] [r0] [r1] r[2] ... [rn] }

	A command message is first sent to specifiy the register locations
	whose contents are to be read. After which, a read operation can be
	performed to read the contents of the specified registers in the
	given sequence.

	After a single read command message is sent. Repeated read operations
	can be performed to continually read the contents of the given
	register sequence. 

	The content of the next register is read and transferred into the i2c
	shift register on each ACK bit that occurs on the i2c bus. Thus, the
	continuous reading operations will read the up-to-date contents of
	the registers.

	It is not necessary to read all the contents of the registers in the
	read operation. If a stop condition is received before all registers
	are transfered the next read operation will read the contents from
	the BEGINNING of the sequence. In this way, you can prioritize the
	most often read registers at the beginning and read the later 
	registers only when required, while still not having to send a new
	read command.

	If you read beyond the end of the register sequence the sequence will
	wrap to the beginning and continue. This allows for continuous 
	scanning of a register sequence without starting a new message.



0x01/W Write device registers (mode A)

	Send { [DA] 0x01 r0 r1 r2 ... rn }
	Send { [DA] 0x00 [r0] [r1] [r2] ... [rn] }

	A command message is first sent to specify the register locations
	whose contents are to be written to. A second message is then sent
	to specify the contents of the registers. Notice the 0x00 after the
	device address is sent. This is to signal the servo that this write
	message is associated with the previous multi-operation command
	message. If this byte was other than 0x00 the servo would interpret
	the write message as a new command.

	Many of the same principles of the read device registers apply here.
	
	Repeated write operations can be performed by sending multiple
	messages or wrapping beyond the register sequence. It is also not
	necessary to write all registers in each message.

	The register is written at the end of each byte transferred.



0x02/R Read device register region (mode A)

	Send { [DA] 0x02 region }
	Receive { [DA] r0 r1 r2 r3 ... rn }

	reads from a region of registers. The first byte is read from the
	register at [region], the next byte from [region+1], the next byte
	from [region+2], etc.

	Repeated read operations can be performed by sending multiple
	messages. The offset is reset to 'region' at the beginning of each
	message.
	
	The register is read at the start of each byte transmission.



0x02/W Write device register region (mode A)

	Send { [DA] 0x02 region }
	Send { [DA] 0x00 r0 r1 r2 r3 ... rn }

	Writes to a region of registers. The first byte is written to the
	register at [region], the next byte to [region+1], the next byte
	to [region+2], etc.

	Repeated write operations can be performed by sending multiple
	messages. The offset is reset to 'region' at the beginning of each
	message.
	
	The register is written at the end of each byte transferred.



0x0a/R Read device info (mode A)

	Send { [DA] 0x0a }
	Receive { [DA] 'S' 'u' 'p' 'e' 'r' 'S' 'e' 'r' 'v' 'o' tab ... 0x00 }

	Reads the servo device information which can contain the SuperServo 
	string, the version and copyright string. Fields are seperated by
	the tab character and the line is terminated by the null character.
	You should continue reading from the device until a 0x00 (null) is 
	encountered.

	

0x0d/R Echo Dual-Operation Command and Register Set (mode A)

	Send { [DA] 0x0d .. .. .. .. }

	This command echos the last dual-operation command back to the
	master controller. It is a convenient way to test the buffer
	capabilities of the device or ensure the device communications
	is working properly.



		*** SINGLE OPERATION (MODE B) COMMANDS ***



0x11 Write device registers (mode B)

	Send { [DA] 0x11 r0 [r0] r1 [r1] r2 [r2] ... rn [rn] }
	
	This command message is performed in a single operation and does not 
	affect setup of dual operation commands.

	The contents to be written to the registers are interplexed with the 
	register locations themselves. Thus pairs of [register, content] are
	sent in a single command message.

	As this mode of command does not affect mode A command messages,
	read command messages can be ocurring before and after a mode B
	write device registers without having to resend the read command
	operation.



0x12 Write device registers region (mode B)

	Send { [DA] 0x12 region [r0] [r1] [r2] ... [rn] }
	
	This command message is performed in a single operation and does not 
	affect setup of dual operation commands.

	This command writes registers in sequence starting at the offset
	specified by the region byte.

	As this mode of command does not affect mode A command messages,
	read command messages can be ocurring before and after a mode B
	write device registers without having to resend the read command
	operation.
	



0x14 Set servo desired position (mode B)

	Send { [DA] 0x14 position (lsb) }

	This command message is performed in a single operation and does not 
	affect setup of dual operation commands.

	Position is the desired position in the range of 0 - 255.

	The ADC that reads the servos current position has a resolution of
	10 bits. Further resolution of the desired position can then also
	be achieved by sending the least significant bits of the position
	in the lsb byte. Only the least significant 2 bits of the lsb
	byte are used. If this byte is omitted, the two lsb's of the
	desired position will be set to 0, thus making the servo resolution
	equivelant to 8bits.



0x15 Set servo desired speed (mode B)

	Send { [DA] 0x15 speed }

	This command message is performed in a single operation and does not 
	affect setup of dual operation commands.

	Speed is the maximum speed of swing in the range of 0 - 255. This
	value is used to restrict the duty cycle of the PWM output.



0x16 Set servo output enable (mode B)

	Send { [DA] 0x16 }

	Enables the output of the PWM to the servo. By default, the output
	of the PWM is disabled so the servos dont jolt on powerup.



0x17 Set servo output disable (mode B)

	Send { [DA] 0x17 }

	Disables the output of the PWM to the servo. 



0x18 Restore Servo Settings (mode B)

	Send { [DA] 0x18 }

	Restores the settings for the servo to factory default values.
	The restored settings include the servo desired position, speed,
	status and the PID coefficients.



0x19 Load Servo Settings (mode B)

	Send { [DA] 0x19 }

	Load saved servo settings from the EEPROM on the PIC (if available).
	The loaded settings include the servo desired position, speed,
	status and the PID coefficients.



0x1a Save Servo Settings (mode B)

	Send { [DA] 0x1a }

	Saves servo settings from the EEPROM on the PIC (if available).
	The saved settings include the servo desired position, speed,
	status and the PID coefficients.



0x1e Reset servo (mode B)

	Send { [DA] 0x1e }

	Resets the servo. This simply resets the PC (program counter) register
	to 0000.



0x1f Enter device programming mode (advanced function)

	Send { [DA] 0x1f }

	NOTE: This command is only valid for device with cpu's supporting
	self-programming!

	This command places the servo in programming mode where the servo
	firmware can be updated. This is an advanced function and should be
	used with care as improper operation of the servo can be result.

	When the servo is placed in programming mode all normal operations
	of the servo halt, including the standard IIC implimentation 
	protocols. See the "Firmware Programming" manual for more info.

	Note: When the servo is placed in programming mode the reset vector
	is redirected to the programming firmware. Thus upon reset the device
	will reenter programming mode Bnd wait for instructions. This is to
	prevent faulty code or a faulty firmware write from rendering the 
	servo inoperable as upon reset the servo will reenter programming 
	mode. 

	The redirection of the reset vector is confirmed by reseting the 
	device at the completion of the "Enter device programming mode"
	command.

	The basic device programming firmware cannot be overwritten, however,
	a second device programming firmware module can be uploaded and
	bootstrapped.

